package com.s8.stack.arch.helium.ssl.outbound;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLException;


/**
 * Just flush bytes, but do not require re-launching 
 * unsafeWrap after that
 * 
 * 
 */
class ShuttingDown extends Mode {

	/**
	 * 
	 * @param outbound
	 */
	public ShuttingDown() {
		super();
	}


	@Override
	public String declare() {
		return "is shutting down...";
	}


	@Override
	public void run(SSL_Outbound.Flow flow) {


		SSLEngine engine = flow.getEngine();

		/*
		 * Closing this side of the engine
		 */


		/* wrapping */
		try {
			boolean isWrapCompleted = false;
			while(!isWrapCompleted) {

				/*
				 * (JAVA doc) states that:
				 * 
				 * In all cases, closure handshake messages are generated by the engine, and
				 * wrap() should be repeatedly called until the resulting SSLEngineResult's
				 * status returns "CLOSED", or isOutboundDone() returns true.
				 * 
				 */
				/* wrapping */
				SSLEngineResult result = flow.getEngine().wrap(
						flow.getApplicationBuffer(), 
						flow.getNetworkBuffer());

				if(flow.isVerbose()) {
					System.out.println(flow.getName()+": "+result);
				}

				// end point listening to result for updating phase
				flow.getConnection().onResult(result);

				if(result.getStatus()==Status.CLOSED || engine.isOutboundDone() || result.bytesProduced()==0) {
					isWrapCompleted = true;
				}
			}

		}
		catch (SSLException e) {
			e.printStackTrace();
		}

		// close outbound
		engine.closeOutbound();
		
		flow.getConnection().close();

		// stop here, don't trigger sending, with no callback
		flow.stop();
	}
}
