package com.s8.stack.arch.helium.ssl.outbound;

import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;

import com.s8.stack.arch.helium.ssl.outbound.SSL_Outbound.Flow;

/**
 * 
 * @author pc
 *
 */
class Wrapping extends Mode {


	//public final static Wrapping MODE = new Wrapping();

	public Wrapping() {
		super();
	}

	@Override
	public String declare() {
		return "is wrapping...";
	}


	@Override
	public void run(SSL_Outbound.Flow flow) {

		if(!flow.getConnection().isClosed) {

			/* <retrieve> */

			/*
			 * Wrapping is greedy, i.e. it retrieves as much application data as possible
			 * before retrying to push to the network
			 */
			flow.pump();

			/* </retrieve> */

			try {

				/* wrapping */
				SSLEngineResult wrapResult = flow.getEngine().wrap(
						flow.getApplicationBuffer(), 
						flow.getNetworkBuffer());

				if(flow.isVerbose()) {
					System.out.println(flow.getName()+": "+wrapResult);
				}

				// end point listening to result for updating phase
				flow.getConnection().onResult(wrapResult);

				/* <handshake-status> */
				switch(wrapResult.getHandshakeStatus()) {

				/* 
				 * run delegated tasks and then see what's required next 
				 */
				case NEED_TASK: 

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // discarded
					case BUFFER_OVERFLOW: // discarded

					case OK:
						flow.then(new RunningDelegates(this));
						break;

					case CLOSED: 
						/*
						 * In all cases, closure handshake messages are generated by the engine, and 
						 * wrap() should be repeatedly called until the resulting SSLEngineResult's status 
						 * returns "CLOSED", or isOutboundDone() returns true. 
						 * All data obtained from the wrap() method should be sent to the peer.
						 */
						// close must be detected separately. Left here for security purposes.

						flow.then(new Flushing()); // release, but need to restart
						break;
					}
					break; // </NEED_TASKS>

				case NEED_WRAP: 

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: handleBufferOverflow(flow); break;



					case CLOSED: 
						/*
						 * In all cases, closure handshake messages are generated by the engine, and 
						 * wrap() should be repeatedly called until the resulting SSLEngineResult's status 
						 * returns "CLOSED", or isOutboundDone() returns true. 
						 * All data obtained from the wrap() method should be sent to the peer.
						 */
						// close must be detected separately. Left here for security purposes.

						// need to come back in flush mode
						flow.then(new Flushing());
						break;


					case OK:
						/*
						 * Since we already are in wrap mode, try concatenating the next wrap into the
						 * networkBuffer, so try to wrap again
						 */
						flow.again();
						break; // stay in wrapping mode
					}
					break; // </NEED_WRAP>

				case NEED_UNWRAP:
				case NEED_UNWRAP_AGAIN: 

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: handleBufferOverflow(flow); break;

					case CLOSED: 
						flow.then(new Closing());
						break;

					case OK: 
						/*
						 * TODO Flush all network bytes and then request unwrapping 
						 */
						flow.then(new Flushing());

						// trigger unwrap
						flow.unwrap();
						break;
					}
					break; // </NEED_UNWRAP>

				case FINISHED: 

					/*
					 * End of handshaking, start independent working of inbound/outbound. Since
					 * Inbound MIGHT have been left in idle mode, wake it up to ensure it is active
					 */
					flow.unwrap();
					// -> continue to next case


				case NOT_HANDSHAKING: // application data

					/*
					 * no more handshaking is requested, so end up here. But we are now in stream mode
					 * (handshake is now completed), so ALWAYS ask for more wrapping. 
					 * 
					 * NOTE: if applicationBuffer is depleted, then networkBuffer will remain empty and
					 * wrap() method will stop by itself.
					 */

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");
					

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: handleBufferOverflow(flow); break;


					/*
					 * Security feature
					 * Already closed
					 */
					case CLOSED: 
						flow.then(new Closing());
						break;


					case OK: 

						// nothing produced, so we don't expect more, so push
						if(wrapResult.bytesProduced()==0) {
							if(flow.getNetworkBuffer().position()>0) {
								
								flow.push(); // push and stop here
								break;
							}
							else { // everything has been pushed
								// go back to idle state
								flow.stop();
								break;
							}
						}
						// try to get more before pushing (greedy)
						else { 
							flow.again();
							break;
						}
					}
					break; // <NOT_HANDSHAKING>
				} 
				/* </handshake-status> */
			}
			catch (SSLException exception) {	
				if(flow.isVerbose()) {
					System.out.println("[Wrapping]: SSL_Exception causes endpoint to close.");
					exception.printStackTrace();
				}
				// Everything went wrong, so try launching the closing procedure
				flow.getConnection().close();
				flow.then(new Closing());
			}
		}
		/*
		 * If closed, immediately fork to a specific closing procedure  
		 */
		else {
			flow.then(new Closing());
		}
	}


	private void handleBufferOverflow(Flow process) throws SSLException {
		/* Network output is not even half-filled, so assume that it is 
		 * under-sized 
		 */
		if(!process.isNetworkBufferHalfFilled()) {
			process.doubleNetworkBufferCapacity();
			//outbound.then(this); -> retry wrapping
		}
		/*
		 * Network output is almost filled, so best solution is to send. But since we
		 * are in handshaking phase, must return to unsafeWrap once networkBuffer bytes have
		 * been written out
		 */
		else {

			/* 
			 *  NEED_WRAP, so ask to retry wrapping after pushing
			 *  process is terminated here, another process will be restarted
			 */
			process.push();
		}
	}



	

}